'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*
 * @Autor: Dejia
 * @Date: 2022-07-05 16:38:07
 * @LastEditors: Dejia
 * @LastEditTime: 2022-07-05 16:38:07
 */
/*
 * @Author: yfl
 * @Date: 2022-03-10 11:35:59
 * @LastEditTime: 2022-03-10 13:43:36
 * @FilePath: \JavaScripts\common\Queue.ts
 */
class Queue {
    elemrnts;
    _size;
    constructor(capacity) {
        this.elemrnts = new Array();
        this._size = capacity;
    }
    push(o) {
        if (o == null) {
            return false;
        }
        if (this._size != undefined && !isNaN(this._size)) {
            if (this.elemrnts.length == this._size) {
                this.pop();
            }
        }
        this.elemrnts.unshift(o);
        return true;
    }
    pop() {
        return this.elemrnts.pop();
    }
    size() {
        return this.elemrnts.length;
    }
    isempty() {
        return this.size() == 0;
    }
    clear() {
        delete this.elemrnts;
        this.elemrnts = new Array();
    }
    show(num) {
        if (num >= 0 && num < this.size()) {
            return this.elemrnts[this.size() - 1 - num];
        }
        else {
            return;
        }
    }
    showsize() {
        return this._size;
    }
    getAll() {
        return this.elemrnts;
    }
}

class UIMultiScroller {
    _index = -1;
    _dataCount;
    _sBox;
    _scrollRoot;
    _movement;
    _itemArr = [];
    // 将未显示出来的Item存入未使用队列里面，等待需要使用的时候直接取出
    _unUsedQueue;
    _maxPerLine = 3;
    // 距离左侧和上册的起始距离
    _leftSpace = 30;
    _topSpace = 30;
    // Item的宽高
    _cellWidth = 500;
    _cellHeight = 100;
    // 行间距X
    _spacingX = 40;
    // 行间距Y
    _spacingY = 20;
    //默认加载行数，一般比可显示行数大2~3行
    _viewLine = 6;
    _itemPrefab;
    _dataArray;
    /**
    * 循环列表构造函数
    * @param sbox       ScrollBox对象ui的引用
    * @param sr         ScrollBox下的节点的引用
    * @param prefab     ScrollBoxItem预制体
    * @param maxPerLine 每行显示的数量
    * @param leftSpace  左边界间距
    * @param topSpace   上边界间距
    * @param cellWidth  ScrollBox下子节点的宽
    * @param cellHeight ScrollBox下子节点的高
    * @param viewCount  ScrollBox的默认加载行数
    * @param spacingX   ScrollBox的行间距X
    * @param spacingY   ScrollBox的行间距Y
    */
    constructor(sbox, sr, preafab, maxPerLine, leftSpace = 30, topSpace = 30, cellWidth = 150, cellHeight = 150, viewCount = 5, spacingX = 40, spacingY = 20) {
        this._sBox = sbox;
        this._scrollRoot = sr;
        this._itemPrefab = preafab;
        this._leftSpace = leftSpace;
        this._topSpace = topSpace;
        this._movement = sbox.orientation;
        this._cellWidth = cellWidth;
        this._cellHeight = cellHeight;
        this._viewLine = viewCount;
        this._spacingX = spacingX;
        this._spacingY = spacingY;
        this._maxPerLine = maxPerLine;
        this._unUsedQueue = new Queue();
        this._sBox.onUserScrolled.add((curOffset) => {
            this.onValueChange();
        });
        this._sBox.onScrollEnd.add(() => {
            this.onValueChange();
        });
    }
    mInitCallback = new mw.Action2();
    /**调用InitData第一次初始化时的回调 */
    get InitCallback() {
        return this.mInitCallback;
    }
    mItemCallback = new mw.Action2();
    /**每个Item刷新时的回调 */
    get ItemCallback() {
        return this.mItemCallback;
    }
    setData(val) {
        this._dataCount = val.length;
        this._dataArray = val;
        this.updateTotalWidth();
        this._index = -1;
        this.resetSBoxPos();
        if (this._itemArr != null) {
            for (let i = this._itemArr.length; i > 0; i--) {
                let item = this._itemArr[i - 1];
                this._itemArr.splice(i - 1, 1);
                this._unUsedQueue.push(item);
                item.uiObject.visibility = mw.SlateVisibility.Collapsed;
            }
            this.onValueChange();
        }
    }
    onValueChange() {
        if (this._itemArr == null || this._dataCount == 0)
            return;
        let index = this.getPosIndex();
        if (index < 0 && this._index > 0) {
            index = 0;
        }
        if (this._index != index && index > -1) {
            this._index = index;
            for (let i = this._itemArr.length; i > 0; i--) {
                let item = this._itemArr[i - 1];
                if (item["scorllIndex"] < index * this._maxPerLine || (item["scorllIndex"] >= (index + this._viewLine) * this._maxPerLine)) {
                    this._itemArr.splice(i - 1, 1);
                    this._unUsedQueue.push(item);
                    item.uiObject.visibility = mw.SlateVisibility.Collapsed;
                }
            }
            for (let i = this._index * this._maxPerLine; i < (this._index + this._viewLine) * this._maxPerLine; i++) {
                if (i < 0)
                    continue;
                if (i > this._dataCount - 1)
                    continue;
                let isOk = false;
                for (let item of this._itemArr) {
                    if (item["scorllIndex"] == i)
                        isOk = true;
                }
                if (isOk)
                    continue;
                this.createItem(i);
            }
        }
    }
    /**
    * 根据索引号 获取当前item的位置
    * @param i   索引
    * @return 返回Pos
    */
    getPosition(i) {
        let xpos = (i % this._maxPerLine);
        let ypos = Math.floor(i / this._maxPerLine);
        switch (this._movement) {
            case mw.Orientation.OrientHorizontal:
                return new mw.Vector2((this._cellWidth + this._spacingX) * ypos + this._leftSpace, ((this._cellHeight + this._spacingY) * xpos) + this._topSpace);
            case mw.Orientation.OrientVertical:
                // return new mw.Vector2(this._cellWidth * xpos + (xpos != 0 ? this._spacingX * xpos : 0) + this._leftSpace, ((this._cellHeight + this._spacingY) * ypos) + this._topSpace);
                return new mw.Vector2((this._cellWidth + this._spacingX) * xpos + this._leftSpace, ((this._cellHeight + this._spacingY) * ypos) + this._topSpace);
        }
        return mw.Vector2.zero;
    }
    onDestroy() {
        this._itemArr = null;
        this._unUsedQueue = null;
    }
    getItemCount() {
        return this._maxPerLine * this._viewLine;
    }
    setItemIndex(item, index) {
        item["scorllIndex"] = index;
        item.uiObject.position = this.getPosition(index);
    }
    createItem(i) {
        let itemBase;
        if (this._unUsedQueue.size() > 0) {
            itemBase = this._unUsedQueue.pop();
            itemBase.uiObject.visibility = mw.SlateVisibility.Visible;
        }
        else {
            if (this._itemPrefab.Gain != null) {
                itemBase = this._itemPrefab.Gain();
            }
            else {
                // itemBase = this._itemPrefab["creat"]();
                itemBase = UIService.create(this._itemPrefab);
            }
            (this._scrollRoot.addChild(itemBase.uiObject));
            itemBase.uiObject.size = (new mw.Vector2(this._cellWidth, this._cellHeight));
            this.mInitCallback.call(i, itemBase);
        }
        this.setItemIndex(itemBase, i);
        if (this._dataArray && itemBase["scorllIndex"] < this._dataArray.length) {
            // itemBase.setData(this._dataArray[itemBase["scorllIndex"]]);
            this.mItemCallback.call(i, itemBase);
        }
        this._itemArr.push(itemBase);
        return;
    }
    /**
    * 获取最上位置的索引
     * @return 返回Pos
    */
    getPosIndex() {
        let pos = this._scrollRoot.position;
        switch (this._movement) {
            case mw.Orientation.OrientHorizontal:
                {
                    return Math.floor(pos.x / -(this._cellWidth + this._spacingX));
                }
            case mw.Orientation.OrientVertical:
                {
                    let ret = pos.y / -(this._cellHeight + this._spacingY);
                    return Math.floor(ret);
                }
        }
        return 0;
    }
    // 这个方法的目的 就是根据总数量 行列 来计算content的真正宽度或者高度
    updateTotalWidth() {
        switch (this._movement) {
            case mw.Orientation.OrientHorizontal:
                let width = this._cellWidth * this._dataCount + this._spacingX * (this._dataCount - 1);
                let height = this._scrollRoot.size.y;
                this._scrollRoot.size = (new mw.Vector2(width, height));
                break;
            case mw.Orientation.OrientVertical:
                let lineCount = Math.ceil(this._dataCount / this._maxPerLine);
                this._scrollRoot.size = (new mw.Vector2(this._scrollRoot.size.x, this._cellHeight * lineCount + this._spacingY * (lineCount - 1) + this._topSpace));
                break;
        }
    }
    resetSBoxPos() {
        // 两句配合才能达到重置到顶部的效果
        this._scrollRoot.position = (new mw.Vector2(0, 0));
        this._sBox.scrollToStart();
        // this._sBox.ScrollToStart();
    }
    reset2BoxTop() {
        // 两句配合才能达到重置到顶部的效果
        this._scrollRoot.position = (new mw.Vector2(0, 0));
        this._sBox.scrollToStart();
    }
}

class BagModuleBaseC extends mwext.ModuleC {
    onAwake() {
    }
    onStart() {
    }
    getItemCnt(cfgId) {
        return this.data.getItemCount(cfgId);
    }
    getItemById(id) {
        return this.data.getItemByItemId(id);
    }
    getItemsByCfg(cfgId) {
        return this.data.getItemsByConfig(cfgId);
    }
    net_ResAddItem2Bag(items) {
        this.data.addItems(items);
        Event.dispatchToLocal("Bag_ItemAddOrDelete", items);
    }
    net_ResItemChange(item) {
        let old = this.data.getItemByItemId(item.id);
        if (old) {
            this.data.setItemByItemId(item.id, item);
            Event.dispatchToLocal("Bag_ItemChanges", item);
        }
    }
    net_ResItemsDelete(ids) {
        let items = [];
        ids.forEach(id => {
            items.push(this.data.getItemByItemId(id));
        });
        this.data.deleteItems(ids);
        Event.dispatchToLocal("Bag_ItemAddOrDelete", items);
    }
} //end
class BagModuleBaseS extends mwext.ModuleS {
    addItemToBag(player, items) {
        let data = this.getPlayerData(player);
        data.addItems(items);
        data.save(false);
        // this.callClientFun(player, this.client.net_ResAddItem2Bag(items));
        this.getClient(player).net_ResAddItem2Bag(items);
    }
    net_ReqDeleteItems(reqs, player) {
        this.ntfItemDelete(player, reqs);
        return true;
    }
    ntfItemChange(player, item) {
        let data = this.getPlayerData(player);
        let old = data.getItemByItemId(item.id);
        if (old) {
            data.setItemByItemId(item.id, item);
            data.save(false);
            // this.callClientFun(player, this.client.net_ResItemChange(item));
            this.getClient(player).net_ResItemChange(item);
        }
    }
    ntfItemDelete(player, itemIds) {
        let data = this.getPlayerData(player);
        data.deleteItems(itemIds);
        data.save(false);
        //this.callClientFun(player, this.client.net_ResItemsDelete(itemIds));
        this.getClient(player).net_ResItemsDelete(itemIds);
    }
} //end
class BagUICfg {
    scrollBox;
    scrollContent;
    renderItemSize;
    horAndVerSpace;
}
mwext.BasePanel.prototype["onAwake"] = function () {
    this.rootCanvas.addChild(this.view.uiObject);
    this.viewSize = this.view.uiObject.size;
    this.viewPosition = this.view.uiObject.position;
    this.viewConstraints = this.view.uiObject.constraints;
    this.view.uiObject.position = mw.Vector2.zero;
    this.view.uiObject.constraints = new mw.UIConstraintAnchors(mw.UIConstraintHorizontal.LeftRight, mw.UIConstraintVertical.TopBottom);
};
mwext.BasePanel.prototype["onAdded"] = function () {
    this.uiObject.size = this.viewSize;
    this.uiObject.position = this.viewPosition;
    this.uiObject.constraints = this.viewConstraints;
};
class BagUIBase extends mwext.BasePanel {
    moduleCls;
    renderCls;
    dataHelper;
    mScroll;
    curDataIds;
    firstBtn;
    tabMap = new Map();
    renderMap = new Map();
    curType = -1;
    curItemId;
    constructor(viewClass, moduleCls, renderCls) {
        super(viewClass);
        // this.view = UIService.create(viewClass);
        this.moduleCls = moduleCls;
        this.renderCls = renderCls;
        this.dataHelper = ModuleService.getModule(moduleCls)["data"];
    }
    onStart() {
        // super.onStart();
        // this.rootCanvas.addChild(this.view.uiObject);
        // this.view.uiObject.position = new mw.Vector2(this.rootCanvas.size.x / 2, this.rootCanvas.size.y / 2);
        //全部重刷
        Event.addLocalListener("Bag_ItemAddOrDelete", (items) => {
            let needUpdate = ModuleService.getModule(this.moduleCls).isSameType(items, this.curType);
            if (needUpdate) {
                this.showItems(ModuleService.getModule(this.moduleCls).getItemIdsByType(this.curType));
            }
        });
        Event.addLocalListener("Bag_ItemChanges", (item) => {
            let needUpdate = ModuleService.getModule(this.moduleCls).isSameType([item], this.curType);
            if (needUpdate) {
                //this.showItems(ModuleService.instance.getModule(moduleCls).getItemsByType(this.curType));
                if (this.curItemId == item.id) {
                    this.showItemDetal(this.dataHelper.getItemByItemId(this.curItemId));
                }
                //更新对应格子,先记录一下
                for (const [renderItem, id] of this.renderMap) {
                    if (id == item.id) {
                        renderItem.setData(this.dataHelper.getItemByItemId(id));
                        renderItem["setData_data"] = this.dataHelper.getItemByItemId(id);
                        break;
                    }
                }
            }
        });
        let cfg = new BagUICfg();
        this.initUICfg(cfg);
        let num_row = Math.floor(cfg.scrollContent.size.x / (cfg.renderItemSize.x + cfg.horAndVerSpace.x));
        let num_col = Math.ceil(cfg.scrollContent.size.y / (cfg.renderItemSize.y + cfg.horAndVerSpace.y)) + 1;
        this.mScroll = new UIMultiScroller(cfg.scrollBox, cfg.scrollContent, this.renderCls, num_row, 0, 0, cfg.renderItemSize.x, cfg.renderItemSize.y, num_col, cfg.horAndVerSpace.x, cfg.horAndVerSpace.y);
        this.mScroll.ItemCallback.add(this.onRefeshItem, this);
        this.mScroll.InitCallback.add(this.onInitItem, this);
        // this.mScroll.Init(MWGameUI.EOrientation.Orient_Vertical);
    }
    onInitItem(index, renderItem) {
        let btn = renderItem.clickObj;
        if (btn) {
            btn.onClicked.add(() => {
                let data = renderItem["setData_data"];
                if (data.id == this.curItemId) {
                    return;
                }
                this.showItemDetal(data);
            });
        }
    }
    onRefeshItem(index, renderItem) {
        let id = this.curDataIds[index];
        let data = this.dataHelper.getItemByItemId(id);
        renderItem.setData(data);
        renderItem["setData_data"] = data;
        renderItem.setSelect(id == this.curItemId);
        this.renderMap.set(renderItem, id);
    }
    showItems(itemIds) {
        this.curDataIds = itemIds;
        if (itemIds.length > 0) {
            this.showItemDetal(this.dataHelper.getItemByItemId(itemIds[0]));
        }
        else {
            this.showItemDetal(null);
        }
        this.renderMap.clear();
        this.mScroll.setData(this.curDataIds);
        //this.mScroll.ScrollToStart();
    }
    addTabs(btn, type, isFirst) {
        btn.onClicked.add(() => {
            let type = this.tabMap.get(btn);
            if (this.curType == type) {
                return;
            }
            this.showItemsByTypes(btn);
        });
        if (isFirst) {
            this.firstBtn = btn;
        }
        this.tabMap.set(btn, type);
    }
    showItemsByTypes(btn) {
        let type = this.tabMap.get(btn);
        this.curType = type;
        let items = (ModuleService.getModule(this.moduleCls)).getItemIdsByType(type);
        this.showItems(items);
        this.tabMap.forEach((ttype, btn) => {
            this.onTabBtnStateChangeCallBack(btn, ttype == this.curType);
        });
    }
    onShow(...params) {
        if (this.firstBtn) {
            this.showItemsByTypes(this.firstBtn);
        }
    }
    showItemDetal(item) {
        this.curItemId = item ? item.id : null;
        this.onShowItemDetal(item);
        for (const [renderItem, id] of this.renderMap) {
            if (id == this.curItemId) {
                renderItem.setSelect(true);
            }
            else {
                renderItem.setSelect(false);
            }
        }
    }
    getSelectData() {
        return this.dataHelper.getItemByItemId(this.curItemId);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 * 玩家道具信息基类
 */
class BagItemBase {
    /** 道具唯一Id */
    id;
    /** 配置Id */
    cfgId;
    /** 数量 */
    count = 0;
}
// export class BagInfo<T extends BagItemBase> extends DataInfo {
//     items: BagMap<T>;
// }
//export class BagModuleDataBase<T extends BagItemBase> extends ModuleData<BagInfo<T>> {
class BagModuleDataBase extends Subdata {
    items;
    get dataName() {
        return "BagInfo";
    }
    // constructor() {
    //     super();
    // }
    initDefaultData() {
        this.items = {};
    }
    /**
     * 通过道具唯一ID获取当前道具
     * @param itemId 唯一id
     * @returns 找到的道具
    */
    getItemByItemId(itemId) {
        return this.items[itemId];
    }
    setItemByItemId(itemId, item) {
        this.items[itemId] = item;
    }
    /**
     * 通过cfgId获取背包里满足的道具列表,可能返回多个
     * @param cfgId 配置ID
     */
    getItemsByConfig(cfgId) {
        let ret = [];
        for (let id in this.items) {
            if (cfgId == this.items[id].cfgId) {
                ret.push(this.items[id]);
            }
        }
        return ret;
    }
    getItemCount(cfgId) {
        let ret = 0;
        for (let id in this.items) {
            if (cfgId == this.items[id].cfgId) {
                ret += this.items[id].count;
            }
        }
        return ret;
    }
    /**
     * 添加道具
     * @param items 要添加的道具列表，外部生成
     */
    addItems(items) {
        items.forEach(item => {
            this.items[item.id] = item;
        });
    }
    /**
     * 删除道具
     * @param ids 要删除的id
     */
    deleteItems(ids) {
        ids.forEach(id => {
            delete this.items[id];
        });
    }
    /**
     * 删除所有道具
     */
    deleteAllItems() {
        this.items = {};
    }
    /**
     * 遍历道具
     * @param call 遍历函数
     */
    forEach(call) {
        for (let id in this.items) {
            call(this.items[id]);
        }
    }
}
__decorate([
    Decorator.persistence()
], BagModuleDataBase.prototype, "items", void 0);

exports.BagItemBase = BagItemBase;
exports.BagModuleBaseC = BagModuleBaseC;
exports.BagModuleBaseS = BagModuleBaseS;
exports.BagModuleDataBase = BagModuleDataBase;
exports.BagUIBase = BagUIBase;
exports.BagUICfg = BagUICfg;
exports.Queue = Queue;
exports.UIMultiScroller = UIMultiScroller;
//# sourceMappingURL=index.js.map
